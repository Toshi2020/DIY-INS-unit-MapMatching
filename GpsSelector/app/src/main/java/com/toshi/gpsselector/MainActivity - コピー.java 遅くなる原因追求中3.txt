package com.toshi.gpsselector;
/*****************************************************************************
*
*	GpsSelector:MainActivity -- NAVI本体GPSと外付けGPSユニットの切換え
*
*	外付けGPSユニットがINSしているときに
*	NAVIの現在値を外付けGPSユニットの値で置き換える
*
*	rev1.0	09.Oct.2021	initial revision by	Toshi
*	rev1.1	02.Mar.2022	画面のキャプチャを追加
*	rev1.2	25.Dec.2025 マップマッチング位置を表示
*
*****************************************************************************/

import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import android.content.Intent;
import android.content.pm.PackageManager;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.SystemClock;
import android.provider.Settings;
import android.util.Log;
import android.view.Gravity;
import android.view.View;
import android.view.ViewTreeObserver;
import android.widget.TextView;
import android.widget.Button;
import android.widget.Toast;
import android.os.Handler;
import android.Manifest;
import java.util.ArrayList;
import androidx.preference.PreferenceManager;
import org.osmdroid.api.IMapController;
import org.osmdroid.config.Configuration;
import org.osmdroid.util.GeoPoint;
import org.osmdroid.views.MapView;
import org.osmdroid.views.overlay.Marker;
import org.osmdroid.views.overlay.ScaleBarOverlay;
import org.osmdroid.views.overlay.Polyline;
import android.content.SharedPreferences;
import java.util.ArrayList;
import java.util.List;
import android.os.Looper;

public class MainActivity extends AppCompatActivity {

	private static final String TAG = "★MainActivity";
	private final int REQUEST_PERMISSIONS_REQUEST_CODE = 1;
	private TextView mTextExtGps;
	private Button mButton;
	private final Handler mTimerHandler = new Handler(Looper.getMainLooper());
	private boolean fLogReq;
	// Map関連
	private static MapInfo mMapInfo;
	private MapView mMapView = null;
	private IMapController mMapController;
	private MapView map = null; 
	private Marker mMarker, mMarker2, mMarker3;
	private ScaleBarOverlay mScaleBarOverlay;
	private static double Latz, Lonz;
	private static float Dirz;
	private static int Satz;
	private float Zoom;
	private static float Zoomz;
	private int AfterTapTime = 1000;
	private List<Polyline> mRoadLines = new ArrayList<>();
	private SharedPreferences sharedPref;
	private static int cnt;
	private int markerIndex;
	private Drawable icNavBlack, icNavRed, icNavNormal;
	private Drawable icNavGreen, icMatchOn, icMatchOff;

	//------------------------------------------------------------------------
	// インスタンス作成時の処理
	//------------------------------------------------------------------------
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		// OpenStreetMap設定
		Configuration.getInstance().load(getApplicationContext(),
				PreferenceManager.getDefaultSharedPreferences(
					getApplicationContext()));

		setContentView(R.layout.activity_main);
		// 設定用画面に置き換え
		if (savedInstanceState == null) {
			getSupportFragmentManager()
					.beginTransaction()
					.replace(R.id.settings, new SettingsFragment())
					.commit();
		}

		// リソースのID取得
		mTextExtGps = (TextView)findViewById(R.id.textViewExtGps);
		mButton = (Button)findViewById(R.id.button);
		mButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				if (AfterTapTime >= 5)	// ダブルクリック防止
				{
					if (fLogReq) {
						fLogReq = false;
						MyService.ReqLogStop();
					} else {
						fLogReq = true;
						MyService.ReqLogStart();
					}
				}
				AfterTapTime = 0;
			}
		});

		// OpenStreetMap初期化
		mMapView = (MapView)findViewById(R.id.mapView);	// リソース取得
		mMapView.setMultiTouchControls(true);		// マルチタッチでズーム可
		mMapController = mMapView.getController();	// Mapコントローラー取得
		mMapController.setZoom(17.9f);	// ズームレベル(18だと道幅が狭くなる)
		// 初期位置は東京駅とする
		GeoPoint centerPoint = new GeoPoint(35.6796388d, 139.7686040d);
		mMapController.setCenter(centerPoint);	// Map中央の座標を設定
		mScaleBarOverlay = new ScaleBarOverlay(mMapView);	// スケールバー
		mScaleBarOverlay.setCentred(true);

		// スケールバーの表示位置
		// onWindowFocusChangedだと2画面からの復帰時にうまくいかない
		ViewTreeObserver observer = mMapView.getViewTreeObserver();
		observer.addOnGlobalLayoutListener(
		new ViewTreeObserver.OnGlobalLayoutListener() {
			@Override
			public void onGlobalLayout() {
				// Viewが作られたらスケールバーをトップセンターに置く
				mScaleBarOverlay.setScaleBarOffset(
								mMapView.getWidth() / 2, 10);
				// スケールバーの表示
				mMapView.getOverlays().add(mScaleBarOverlay);
			}
		});
		mMarker = new Marker(mMapView);			// マーカー
		mMarker2 = new Marker(mMapView);
		mMarker3 = new Marker(mMapView);
		mMapView.getOverlays().add(mMarker);
		mMapView.getOverlays().add(mMarker2);
		mMapView.getOverlays().add(mMarker3);

		mMarker.setEnabled(true);
		mMarker2.setEnabled(false);
		mMarker3.setEnabled(false);
		mScaleBarOverlay.setEnabled(true);

		// マーカーの先頭インデックスを取得
		markerIndex = mMapView.getOverlays().indexOf(mMarker);
		if (markerIndex < 0) markerIndex = mMapView.getOverlays().size();

		icNavBlack = getDrawable(R.drawable.ic_baseline_navigation_40_black);
		icNavRed   = getDrawable(R.drawable.ic_baseline_navigation_40_red);
		icNavNormal= getDrawable(R.drawable.ic_baseline_navigation_40);
		icNavGreen = getDrawable(R.drawable.ic_baseline_navigation_40_green);
		icMatchOn  = getDrawable(R.drawable.point_scan_24px2);
		icMatchOff = getDrawable(R.drawable.point_scan_24px);

		// 画面キャプチャはオフ
		sharedPref = PreferenceManager.getDefaultSharedPreferences(this);
		SharedPreferences.Editor ed = sharedPref.edit();
		ed.putBoolean("MOCK2", false).apply();
		ed.putBoolean("CAPTURE_SW", false).apply();

		// タイマー開始
		mTimerHandler.postDelayed(TimerTask, 100);
	}
	//------------------------------------------------------------------------
	// 初回表示時およびポーズからの復帰時
	//------------------------------------------------------------------------
	@Override
	protected void onResume()
	{
		super.onResume();
		cnt = 0;
		if (mMapView != null) {
			mMapView.onResume();
		}
		try {
			// Android11以降でDocumentsフォルダにアクセスするために
			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
				if (!Environment.isExternalStorageManager()) {
					ToastShow("次の画面で許可をしたら再起動してください");
				    Intent intent = new Intent(
				      Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION);
				    intent.setData(Uri.parse("package:" + getPackageName()));
			   	 startActivity(intent);
			   	 finish();
			   	 return;
				}
			}
			// 必要なパーミッションを要求
			List<String> perms = new ArrayList<>();
			perms.add(Manifest.permission.ACCESS_FINE_LOCATION);

			if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {
				perms.add(Manifest.permission.WRITE_EXTERNAL_STORAGE);
			}
			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
				perms.add(Manifest.permission.BLUETOOTH_CONNECT);
			}

			requestPermissionsIfNecessary(perms.toArray(new String[0]));
		} catch(Exception e){
		}
	}
	//------------------------------------------------------------------------
	// ポーズ時
	//------------------------------------------------------------------------
	@Override
	public void onPause() {
		super.onPause();
		if (mMapView != null) {
			mMapView.onPause();
		}
	}
	//------------------------------------------------------------------------
	// パーミッション要求結果の受け取り
	//------------------------------------------------------------------------
	@Override
	public void onRequestPermissionsResult(int requestCode,
					String[] permissions, int[] grantResults) {
		super.onRequestPermissionsResult(
				requestCode, permissions, grantResults);

		if (requestCode == REQUEST_PERMISSIONS_REQUEST_CODE) {
			boolean allGranted = true;
			for (int result : grantResults) {
				if (result != PackageManager.PERMISSION_GRANTED) {
					allGranted = false;
					break;
				}
			}
			if (!allGranted) {
				ToastShow("設定から許可してください。");
			}
		}
	}
	//------------------------------------------------------------------------
	// 必要なパーミッションを要求
	//------------------------------------------------------------------------
	private void requestPermissionsIfNecessary(String[] permissions) {
		ArrayList<String> permissionsToRequest = new ArrayList<>();
		for (String permission : permissions) {
			 if (ContextCompat.checkSelfPermission(this, permission)
					!= PackageManager.PERMISSION_GRANTED) {
				permissionsToRequest.add(permission);
			}
		}
		if (permissionsToRequest.size() > 0) {
			ActivityCompat.requestPermissions(
				this,
				permissionsToRequest.toArray(new String[0]),
				REQUEST_PERMISSIONS_REQUEST_CODE);
		}
	}
	//------------------------------------------------------------------------
	// 終了時処理
	//------------------------------------------------------------------------
	@Override
	protected void onDestroy() {
		super.onDestroy();
		Log.d(TAG,"onDestroy");

		MyService.ReqLogStop();	// ログ停止

		// タイマー終了
		mTimerHandler.removeCallbacks(TimerTask);
	}
//****************************************************************************
// タイマー
//
static long now;
	//------------------------------------------------------------------------
	// タイマー割込み処理
	//------------------------------------------------------------------------
	private final Runnable TimerTask = new Runnable() {

		long next = SystemClock.uptimeMillis();

		@Override
		public void run() {
now = System.currentTimeMillis();

			next += 100;

			if (AfterTapTime < 30000)	// ボタンタップ後の時間
			{
				AfterTapTime++;
			}
			String s = MyService.GetStrIns();	// 表示文字列を取得
			if (!s.equals("")) {
				mTextExtGps.setText(s);			// データ表示
			}
			long lin = MyService.GetLogLine();	// ログした行数
			s = String.valueOf(lin);
			if (MyService.IsLogging()) {
				mButton.setText("\n■\t" + s + "\n");	// 行数表示
			} else {
				mButton.setText("\n●Log開始\n");
			}

			// 画面がオフしたら
			if (MyService.IsScreenOff()) {
				finish();	// メインアクティビティは終了させておく
			}

			// Map表示更新
			DrawMap();

			// タイマー再開
			mTimerHandler.postDelayed(this, 100);
//			mTimerHandler.postAtTime(this, next);
Log.d(TAG, String.valueOf(System.currentTimeMillis() - now));
		}
	};
	//------------------------------------------------------------------------
	// 車速にヒスを入れる
	//------------------------------------------------------------------------
	static float xz;
	private float his(float x) {
		float hisx = 5.0f;	// ヒスの幅
		if (x >= xz + hisx)
		{
			xz += hisx;
		} else if (x <= xz - hisx) {
			xz -= hisx;
		}
		if (xz < 0) xz = 0;
		return xz;
	}
	//------------------------------------------------------------------------
	// Map表示更新
	//------------------------------------------------------------------------
	private void DrawMap() {
		boolean fgpsdisp = false;
		boolean fmatchdisp = false;
		boolean fMapMatch = sharedPref.getBoolean("MOCK1", false);
		try {
		  mMapInfo = MyService.GetMapInfo();	// Map表示用データを取得
		  // データが更新されたら
		  if ((Latz != mMapInfo.lat || Lonz != mMapInfo.lon ||
				Dirz != mMapInfo.dir || Satz != mMapInfo.sat) &&
				mMapInfo.lat != 0.0d && mMapInfo.lon != 0.0d){
			// Map中央の座標
			GeoPoint centerPoint = 
						new GeoPoint(mMapInfo.lat, mMapInfo.lon);
			// GPSの座標(仮にINSと同じに)
			GeoPoint gpspoint = new GeoPoint(mMapInfo.lat, mMapInfo.lon);
			// GPS座標が存在するなら
			if (mMapInfo.gpslat > 0.0d) {
				gpspoint.setCoords(mMapInfo.gpslat, mMapInfo.gpslon);
				fgpsdisp = true;
			}
			// MapMatchの座標
			GeoPoint matchpoint =
					new GeoPoint(mMapInfo.matchlat, mMapInfo.matchlon);
			// MapMatch座標が存在するなら
			if (mMapInfo.matchlat > 0.0d) {
				matchpoint.setCoords(mMapInfo.matchlat,mMapInfo.matchlon);
				fmatchdisp = true;
			}
			if (cnt == 0) {

				mMapController.setCenter(centerPoint);// Map移動

				// マップマッチ道路を表示
				List<List<GeoPoint>> roads = MyService.GetRoads();
				if (roads != null && fMapMatch) {
					drawRoads(roads);	// 道路ラインを描画
				}
			}
			if (++cnt >= 3) {
				cnt = 0;
			}

			mMarker.setPosition(centerPoint);	// Map中央に表示
			mMarker2.setPosition(gpspoint);		// GPS位置に表示
			mMarker3.setPosition(matchpoint);	// Match位置に表示
			// 回転の中央を設定
			mMarker.setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_CENTER);
			mMarker2.setAnchor(Marker.ANCHOR_CENTER,Marker.ANCHOR_CENTER);
			mMarker3.setAnchor(Marker.ANCHOR_CENTER,Marker.ANCHOR_CENTER);
			// ズームレベルの決定
			// ズームレベル最大、最小、最小となる車速
			float zmax = 17.9f, zmin = 16.9f, vmax = 100.0f;
			float v = his(mMapInfo.speed);	// 車速にヒスを入れる
			if (v <= 0.0) {
				Zoom = zmax;
			} else if (v >= vmax) {
				Zoom = zmin;
			} else {
				Zoom = zmax - (zmax - zmin) * v / vmax;
			}
			if (Zoom != Zoomz) {
				mMapController.setZoom(Zoom);
			}

			// アイコンを設定
			switch (mMapInfo.sat) {
				case 0:	// GPSロスト中
				case 1:	// GPSロスト中
					mMarker.setIcon(icNavBlack);
					break;
				case 2:	// GPS FIX中だが疑わしい
					mMarker.setIcon(icNavRed);
					break;
				default:	// GPS FIX中かつ信用できる
					mMarker.setIcon(icNavNormal);
			}
			mMarker2.setIcon(icNavGreen);
			mMarker3.setIcon(mMapInfo.fmatching ? icMatchOn : icMatchOff);

			// マーカーの角度(右が負)
			mMarker.setRotation(-mMapInfo.dir);
			mMarker2.setRotation(-mMapInfo.gpsdir);

			// マーカーを表示/非表示
			mMarker2.setEnabled(fgpsdisp);
			mMarker3.setEnabled(fmatchdisp && mMapInfo.fmatch);

			mMapView.invalidate();
		  }
		  Latz = mMapInfo.lat;
		  Lonz = mMapInfo.lon;
		  Dirz = mMapInfo.dir;
		  Satz = mMapInfo.sat;
		  Zoomz = Zoom;
		} catch(Exception e){	// ありえない座標だった場合のF/S
			ToastShow("OSM error");
		}
	}
	//------------------------------------------------------------------------
	// 道路 Polyline を描画する
	//------------------------------------------------------------------------
	private static int prevMatchIndex = -1;
	private void drawRoads(List<List<GeoPoint>> roads) {

		if (roads == null || roads.isEmpty()) return;
		
		int matchIndex = MyService.getMatchRoadIndex();

		if (matchIndex == prevMatchIndex) return;

		prevMatchIndex = matchIndex;

		// 以前のラインを削除
		for (Polyline line : mRoadLines) {
			mMapView.getOverlays().remove(line);
		}
		mRoadLines.clear();

		for (int i = 0; i < roads.size(); i++) {

			List<GeoPoint> gpList = roads.get(i);
			Polyline line = new Polyline();
			line.setPoints(gpList);

			if (i == matchIndex) {
				// MapMatch で選択された道路だけ赤色
				line.getOutlinePaint().setColor(0xFFFF0000);
				line.getOutlinePaint().setStrokeWidth(4f);
			} else {
				// その他の道路はグレー
				line.getOutlinePaint().setColor(0xFF888888);
				line.getOutlinePaint().setStrokeWidth(4f);
			}
			// 道路をマーカーより下に挿入
			mMapView.getOverlays().add(markerIndex, line);
			mRoadLines.add(line);
		}
		// ジオポイントにドットを打つ
		if (matchIndex >= 0 && matchIndex < roads.size()) {
//				drawMatchPointMarkers(roads.get(matchIndex));
		}
	}
	//------------------------------------------------------------------------
	// GeoPoint に小さな点マーカーを付ける（マッチした道路だけ）
	//------------------------------------------------------------------------
	private List<Marker> matchPointMarkers = new ArrayList<>();

	private void drawMatchPointMarkers(List<GeoPoint> gpList) {

		// 古いマーカー削除
		for (Marker mk : matchPointMarkers) {
			mMapView.getOverlays().remove(mk);
		}
		matchPointMarkers.clear();

		if (gpList == null) return;

		for (GeoPoint gp : gpList) {
			Marker mk = new Marker(mMapView);
			mk.setPosition(gp);
			mk.setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_CENTER);
			mk.setIcon(getDrawable(R.drawable.point_small));
			mk.setInfoWindow(null);

			mMapView.getOverlays().add(markerIndex, mk);
			matchPointMarkers.add(mk);
		}
	}
//****************************************************************************
// 画面表示
//
	private static Toast tst;
	//------------------------------------------------------------------------
	// toast出力
	//------------------------------------------------------------------------
	private void ToastShow(String str) {
		tst = Toast.makeText(this, str, Toast.LENGTH_SHORT);
		// 画面の中央に表示
		tst.setGravity(Gravity.CENTER, 0, 0);
		tst.show();
	}
}
